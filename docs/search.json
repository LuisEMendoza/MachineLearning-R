[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inicio",
    "section": "",
    "text": "En estos apuntes estaré escribiendo todo lo que vaya encontrando en la red sobre el Aprendizaje Máquina con el lenguaje R. Planifico crear otro sitio con apuntes sobre Python, Julia y probablemente Java.\nEl código R se muestra abajo y enseguida la salida.\n\n1 + 1\n\n[1] 2\n\n\nConforme se vuelvan más complejos estos apuntes iré agregando métodos más eficientes de navegación. Edit: ya se agregó una entrada nueva: Adquisición.\nSe debe instalar el paquete class con\ninstall.packages(\"class\")"
  },
  {
    "objectID": "SL-Classification-01.html",
    "href": "SL-Classification-01.html",
    "title": "Aprendizaje Supervisado en R: Clasificación",
    "section": "",
    "text": "Se trata de algortimos que utilizan la cercanía en cuanto a ciertos valores de las variables consideradas importantes para realizar una clasificación.\n\n\nDespués de haber tenido un humano detrás del volante por varios viajes, es hora de que el coche autónomo intente probarse a sí mismo.\nAl comienzo del viaje, la cámara obtiene la imagen de una señal vial de alto. Esta se;al ha sido codificada siguiendo parámetros que pueden ser leidos por el algoritmo y se almacenan en un conjunto de datos llamado next_sign. Apliquemos un clasificador kNN para ayudar al coche a reconocer la señal.\nCarguemos tanto la librería class como el set de datos signs, el cual contiene las observaciones de entrenamiento. Lo primero lo realizamos de la manera habitual:\n\nlibrary(class)\n\nLo segundo lo haremos de una manera diferente, ya que nuestros datos se encuentran en un archivo de texto independiente de RStudio. Utilizaremos read.csv() para leer el contenido del archivo que contiene nuestro set de datos.\n\nsigns <- read.csv(\"Datasets/signs.csv\")\n\nGuardaremos la lectura a una variable signs, que nos representará en los sucesivo al conjunto de datos. Ahora crearemos un vector de etiquetas, al cual le asignaremos el contenido de la columna sign_type contenida en el conjunto de datos signs. Recordemos que la selección de una columna se consigue con el símbolo $, indicando el set original y en seguida la columna de interés:\n\nsign_types <- signs$sign_type\n\nAhora cargaremos los datos que representan la imagen tomada que queremos clasificar:\n\nnext_sign <- read.csv(\"Datasets/next_sign.csv\")\n\nEs momento de realizar la clasificación de la nueva imagen con la función knn(). Configuraremos sus argumentos de la siguiente manera.\n\ntrain se refiere a los datos de entrenamiento o de ejemplo, y en este caso será igual al data frame signs pero retirando la columna de las etiquetas (recordemos que esa la usamos para el vector de etiquetas sign_types).\nEl argumento test se refiere a los datos que se desean clasificar. Utilizaremos los correspondientes al data frame next_sign.\nEl último argumento a utilizar será cl, al cual le alimentaremos el vector de etiquetas sign_types.\n\n\nknn(train = signs[, -1], test = next_sign, cl = sign_types)\n\n[1] stop\nLevels: pedestrian speed stop\n\n\nEl resultado arrojado nos indica que efectivamente, es una señal de Alto. Luego nos muestra los posibles resultados a esta cuestión.\n\n\n\nHemos conseguido enseñarle a la máquina a reconocer una señal de alto. Sin embargo, debemos conocer qué información le dimos para lograrlo. Básicamente, el conjunto de datos que alimentamos como el entrenamiento contiene una simplificación numérica de las imágenes que representan señales viales. Veamos cómo se obtuvieron.\nCada fotografía de señales viales fue dividida en una rejilla de 4x4, dando 16 partes representadas por cuadrados. Enseguida se extrajo el color del píxel central de cada uno de estos cuadros. El color fue cuantificado considerando el nivel RGB, es decir, la cantidad de rojo, verde y azul de dicho píxel. Recordemos que los valores RGB van desde 0 hasta 255. Así se obtuvo el conjunto de entrenamiento, con hasta 48 valores representando cada fotografía de señales viales.\nExploremos el set de datos. Primero el panorama general algo resumido con str():\n\nstr(signs)\n\n'data.frame':   205 obs. of  49 variables:\n $ sign_type: chr  \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" ...\n $ r1       : int  155 142 57 22 169 75 136 118 149 13 ...\n $ g1       : int  228 217 54 35 179 67 149 105 225 34 ...\n $ b1       : int  251 242 50 41 170 60 157 69 241 28 ...\n $ r2       : int  135 166 187 171 231 131 200 244 34 5 ...\n $ g2       : int  188 204 201 178 254 89 203 245 45 21 ...\n $ b2       : int  101 44 68 26 27 53 107 67 1 11 ...\n $ r3       : int  156 142 51 19 97 214 150 132 155 123 ...\n $ g3       : int  227 217 51 27 107 144 167 123 226 154 ...\n $ b3       : int  245 242 45 29 99 75 134 12 238 140 ...\n $ r4       : int  145 147 59 19 123 156 171 138 147 21 ...\n $ g4       : int  211 219 62 27 147 169 218 123 222 46 ...\n $ b4       : int  228 242 65 29 152 190 252 85 242 41 ...\n $ r5       : int  166 164 156 42 221 67 171 254 170 36 ...\n $ g5       : int  233 228 171 37 236 50 158 254 191 60 ...\n $ b5       : int  245 229 50 3 117 36 108 92 113 26 ...\n $ r6       : int  212 84 254 217 205 37 157 241 26 75 ...\n $ g6       : int  254 116 255 228 225 36 186 240 37 108 ...\n $ b6       : int  52 17 36 19 80 42 11 108 12 44 ...\n $ r7       : int  212 217 211 221 235 44 26 254 34 13 ...\n $ g7       : int  254 254 226 235 254 42 35 254 45 27 ...\n $ b7       : int  11 26 70 20 60 44 10 99 19 25 ...\n $ r8       : int  188 155 78 181 90 192 180 108 221 133 ...\n $ g8       : int  229 203 73 183 110 131 211 106 249 163 ...\n $ b8       : int  117 128 64 73 9 73 236 27 184 126 ...\n $ r9       : int  170 213 220 237 216 123 129 135 226 83 ...\n $ g9       : int  216 253 234 234 236 74 109 123 246 125 ...\n $ b9       : int  120 51 59 44 66 22 73 40 59 19 ...\n $ r10      : int  211 217 254 251 229 36 161 254 30 13 ...\n $ g10      : int  254 255 255 254 255 34 190 254 40 27 ...\n $ b10      : int  3 21 51 2 12 37 10 115 34 25 ...\n $ r11      : int  212 217 253 235 235 44 161 254 34 9 ...\n $ g11      : int  254 255 255 243 254 42 190 254 44 23 ...\n $ b11      : int  19 21 44 12 60 44 6 99 35 18 ...\n $ r12      : int  172 158 66 19 163 197 187 138 241 85 ...\n $ g12      : int  235 225 68 27 168 114 215 123 255 128 ...\n $ b12      : int  244 237 68 29 152 21 236 85 54 21 ...\n $ r13      : int  172 164 69 20 124 171 141 118 205 83 ...\n $ g13      : int  235 227 65 29 117 102 142 105 229 125 ...\n $ b13      : int  244 237 59 34 91 26 140 75 46 19 ...\n $ r14      : int  172 182 76 64 188 197 189 131 226 85 ...\n $ g14      : int  228 228 84 61 205 114 171 124 246 128 ...\n $ b14      : int  235 143 22 4 78 21 140 5 59 21 ...\n $ r15      : int  177 171 82 211 125 123 214 106 235 85 ...\n $ g15      : int  235 228 93 222 147 74 221 94 252 128 ...\n $ b15      : int  244 196 17 78 20 22 201 53 67 21 ...\n $ r16      : int  22 164 58 19 160 180 188 101 237 83 ...\n $ g16      : int  52 227 60 27 183 107 211 91 254 125 ...\n $ b16      : int  53 237 60 29 187 26 227 59 53 19 ...\n\n\nSupongamos que deseamos saber cuántas señales de cada tipo están contenidas en nuestros datos. Eso se consigue con la función table() con la columna de los tipos de señal como argumento (no olvidemos que es la primera columna).\n\ntable(signs[, 1])\n\n\npedestrian      speed       stop \n        65         70         70 \n\n\nEs posible revisar los niveles promedio de color de alguna columna específica con el comando aggregate(). Calculemos el promedio de color del décimo cuadro pero clasificado por tipo de señal:\n\naggregate(r10 ~ sign_type, data = signs, mean)\n\n   sign_type       r10\n1 pedestrian 108.78462\n2      speed  83.08571\n3       stop 141.08571\n\n\nDesglosemos esta función. El primer argumento es la forma de organizar los datos, la columna r10 con respecto a la que que contiene los nombres del tipo de señal; enseguida escribimos el nombre del conjunto de datos y al final cuál medida estadística deseamos calcular.\n\n\n\nAhora realizaremos una prueba de manejo que incluye 59 señales adicionales divididas en tres categorías: alto, límite de velocidad y paso peatonal. Al final de la prueba, debemos medir el nivel de éxito del coche en reconocer dichas señales. Seguiremos trabajando con nuestro conjunto de datos con la adición de los datos de prueba, llamados test_signs.\n\ntest_signs <- read.csv(\"Datasets/test_signs.csv\")\n\nClasifiquemos los datos de las señales de prueba con knn() y asignemos el resultado a una variable.\n\ntrain volverá a ser nuestros datos de entrenamiento sin etiquetas.\ntest se refiere ahora a los datos de prueba test_signs, también sin etiquetas.\ncl vuelve a ser el vector de etiquetas creado anteriormente.\n\n\nsign_types <- signs$sign_type\nsigns_pred <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types)\nsigns_pred\n\n [1] pedestrian pedestrian pedestrian pedestrian pedestrian pedestrian\n [7] pedestrian pedestrian pedestrian pedestrian pedestrian pedestrian\n[13] pedestrian pedestrian pedestrian pedestrian pedestrian pedestrian\n[19] pedestrian speed      speed      speed      speed      speed     \n[25] speed      speed      speed      speed      speed      speed     \n[31] speed      speed      speed      speed      speed      speed     \n[37] speed      speed      speed      speed      stop       stop      \n[43] stop       stop       stop       stop       stop       stop      \n[49] stop       stop       stop       stop       stop       stop      \n[55] stop       stop       stop       stop       stop      \nLevels: pedestrian speed stop\n\n\nR nos devuelve el conjunto de sus lecturas en cuanto a las señales viales que encontró en la prueba. Toca verificar qué tan preciso resultó ser nuestro modelo con respecto a las señales reales. Para ello, primero crearemos un vector con las etiquetas de las señales reales y después con la función table() crearemos una tabla cruzada o matriz de confusión que compare los valores pronosticados contra los reales:\n\nsigns_actual <- test_signs$sign_type\nsigns_actual\n\n [1] \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\"\n [6] \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\"\n[11] \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\"\n[16] \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" \"speed\"     \n[21] \"speed\"      \"speed\"      \"speed\"      \"speed\"      \"speed\"     \n[26] \"speed\"      \"speed\"      \"speed\"      \"speed\"      \"speed\"     \n[31] \"speed\"      \"speed\"      \"speed\"      \"speed\"      \"speed\"     \n[36] \"speed\"      \"speed\"      \"speed\"      \"speed\"      \"speed\"     \n[41] \"stop\"       \"stop\"       \"stop\"       \"stop\"       \"stop\"      \n[46] \"stop\"       \"stop\"       \"stop\"       \"stop\"       \"stop\"      \n[51] \"stop\"       \"stop\"       \"stop\"       \"stop\"       \"stop\"      \n[56] \"stop\"       \"stop\"       \"stop\"       \"stop\"      \n\ntable(signs_pred, signs_actual)\n\n            signs_actual\nsigns_pred   pedestrian speed stop\n  pedestrian         19     0    0\n  speed               0    21    0\n  stop                0     0   19\n\n\nCalculemos la precisión de nuestro modelo:\n\nmean(signs_pred == signs_actual)\n\n[1] 1\n\n\nResultó ser totalmente preciso, lo cual no es normal que ocurra siempre.\n\n\n\nEl valor de la constante k permite modificar el rendimiento de nuestros algoritmos. La k se refiere al número de vecinos a tomar en cuenta para la clasificación. Por ejemplo, si lo dejamos sin modificar, R dará un valor de k = 1, por lo que elegirá solo la imagen más cercana a la prueba. Si incrementamos el valor, se tomará en cuenta tantos vecinos como valga la k y eso podría redundar en una mayor exactitud del modelo al tener más elementos que considerar. Sin embargo, esto no siempre es lo mejor, ya que valores pequeños pueden detectar patrones más sutiles en nuestro modelo.\nProbemos valores de k a 1, 7 y 25 para examinar su impacto en la exactitud del modelo de aprendizaje:\n\nk_1 <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types)\nmean(signs_actual == k_1)\n\n[1] 1\n\n\nAhora probemos con 7 vecinos.\n\nk_7 <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types, k = 7)\nmean(signs_actual == k_7)\n\n[1] 0.9661017\n\n\nY con 25:\n\nk_25 <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types, k = 25)\nmean(signs_actual == k_25)\n\n[1] 0.9322034\n\n\n\n\n\nCuando múltiples vecinos más cercanos obtienen un voto, puede ser útil en ocasiones examinar si los votos fueron unánimes o dispersos. Por ejemplo, saber más acerca de la seguridad con que se realizaron los votos podría permitirle a un vehículo autónomo tener precaución por si existe la posibilidad de toparse una señal de alto enfrente.\nEn este ejercicio veremos cómo obtener los resultados de la votación a partir de la función knn().\nUsaremos una k = 7 y los datos ya conocidos, con la salvedad de agregar un argumento más, prob = TRUE. El resultado lo asignamos a una variable\n\nsign_pred2 <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types, k = 7, prob = TRUE)\n\nLa función que nos permite obtener las proporciones de los votos es attr(), dándole como argumentos la variable obtenida antes y el atributo \"prob\".\n\nsign_prob <- attr(sign_pred2, \"prob\")\n\nAhora examinemos los resultados de nuestra predicción y la proporción de votos para la clase ganadora:\n\nhead(sign_pred2)\n\n[1] pedestrian pedestrian pedestrian stop       pedestrian pedestrian\nLevels: pedestrian speed stop\n\n\n\nhead(sign_prob)\n\n[1] 0.5714286 0.7142857 0.8571429 0.4285714 1.0000000 0.8571429"
  },
  {
    "objectID": "DataAdquisition-01.html",
    "href": "DataAdquisition-01.html",
    "title": "Adquisición de datos",
    "section": "",
    "text": "Es importante saber dónde encontrar y preparar los datos. Es posible obtenerlos en archivos CSV o JSON, pero eso no nos exime de tener que prepararlos o adecuarlos para aplicar algún modelo. Veamos cómo extraer los datos a partir de un csv."
  },
  {
    "objectID": "DataAdquisition-01.html#extrayendo-un-csv",
    "href": "DataAdquisition-01.html#extrayendo-un-csv",
    "title": "Adquisición de datos",
    "section": "Extrayendo un csv",
    "text": "Extrayendo un csv\nTrabajaremos con datos que ya están disponibles en el propio R (es el de mtcars), pero ahora como si fueran externos. Para ello extraeremos los valores desde un archivo de texto en formato csv y mostraremos un breve resumen del mismo con la función head() con dos argumentos, el nombre de la variable y el número de filas que deseamos mostrar. Dicho archivo se encuentra en la carpeta de Datasets del repositorio.\n\nautos <- read.csv(file = \"Datasets/Adquisition/auto-mpg.csv\", header = TRUE, sep = \",\")\nhead(autos, 5)\n\n  No mpg cylinders displacement horsepower weight acceleration model_year\n1  1  28         4          140         90   2264         15.5         71\n2  2  19         3           70         97   2330         13.5         72\n3  3  36         4          107         75   2205         14.5         82\n4  4  28         4           97         92   2288         17.0         72\n5  5  21         6          199         90   2648         15.0         70\n             car_name\n1 chevrolet vega 2300\n2     mazda rx2 coupe\n3        honda accord\n4     datsun 510 (sw)\n5         amc gremlin\n\n\nLa función que utilizamos read.csv() admite algunos parámetros. Los que nos importan de momento son los que se pueden ver en el bloque de código anterior:\n\nfile =. El archivo que se va a leer entrecomillado.\nheader =. Si el archivo contiene cabecera, lo dejamos con su valor por defecto, TRUE.\nsep =. El tipo de separador, que usualmente es una coma “,”.\n\nSi deseamos visualizar únicamente los nombres de las variables o columnas, utilizamos el comando:\n\nnames(autos)\n\n[1] \"No\"           \"mpg\"          \"cylinders\"    \"displacement\" \"horsepower\"  \n[6] \"weight\"       \"acceleration\" \"model_year\"   \"car_name\"    \n\n\n\nOpciones adicionales\nSi en dado caso el separador es diferente, por ejemplo \";\", utilizamos la función read.csv2(). Cabe mencionar que el separador tabulador puede representarse en R como \"t\".\nSi nuestro conjunto de datos no tiene cabecera, hay que indicarlo con header = FALSE. Además, podemos agregar dicha cabecera utilizando el argumento col.names = c(\"Nombre1\", \"Nombre2\", \"NombreTal\")\nSi nuestro set de datos contiene huecos, es posible darles un tratamiento específico con la sentencia na.strings = \"\".\nSi queremos evitar que R trate a las variables categóricas como factores, lo especificamos con la sentencia stringsAsFactors = FALSE. Si queremos trabajarlas como cadenas de caracteres, utilizamos as.character().\nSi queremos leer un archivo remoto, basta con usar la misma función pero cambiando la ruta por la url del archivo:\n\nautos_internet <- read.csv(\"https://github.com/LuisEMendoza/MachineLearning-R/blob/main/Datasets/Adquisition/auto-mpg.csv\")\nhead(autos_internet, 5)\n\n                                                                                                  X..DOCTYPE.html.\n1 <html lang=en data-color-mode=auto data-light-theme=light data-dark-theme=dark data-a11y-animated-images=system>\n2                                                                                                           <head>\n3                                                                                             <meta charset=utf-8>\n4                                                     <link rel=dns-prefetch href=https://github.githubassets.com>\n5                                               <link rel=dns-prefetch href=https://avatars.githubusercontent.com>"
  },
  {
    "objectID": "DataAdquisition-01.html#extrayendo-un-xml",
    "href": "DataAdquisition-01.html#extrayendo-un-xml",
    "title": "Adquisición de datos",
    "section": "Extrayendo un xml",
    "text": "Extrayendo un xml\nEs necesario instalar un paquete adicional en R llamado XML. Usamos la sentencia de costumbre\ninstall.packages(\"XML\")\nCargamos este paquete con\n\nlibrary(XML)\n\nY leemos el archivo desde su ubicación local. Por ejemplo, el archivo a leer se encuentra en la ubicación local Datasets/Adquisition/cd_catalog.xml. Por simplicidad, asignaremos la ruta a una variable llamada UrlXml\n\nurl_xml <- \"Datasets/Adquisition/cd_catalog.xml\"\n\nSin embargo, debemos crear un apuntador que nos permita hurgar en el archivo:\n\nxml_apuntador <- xmlParse(url_xml)\napuntador_root <- xmlRoot(xml_apuntador)\n\nAdemás de construir un dataframe con el mismo. Procedemos de la siguiente manera:\n\nxml_data <- xmlSApply(apuntador_root, function(x) xmlSApply(x, xmlValue))\nxml_dataframe <-  data.frame(t(xml_data), row.names = NULL)\n\nEs importante notar que se traspuso el dataframe debido a que la estructura de los xml nos habr[ia generado las variables como filas. Recordemos que siempre deseamos que las variables se encuentren en las columnas. También eliminamos los nombres de las filas con la sentencia row.names = NULL.\nMostremos el resultado con al menos 5 valores.\n\nhead(xml_dataframe, 5)\n\n                TITLE          ARTIST COUNTRY        COMPANY PRICE YEAR\n1    Empire Burlesque       Bob Dylan     USA       Columbia 10.90 1985\n2     Hide your heart    Bonnie Tyler      UK    CBS Records  9.90 1988\n3       Greatest Hits    Dolly Parton     USA            RCA  9.90 1982\n4 Still got the blues      Gary Moore      UK Virgin records 10.20 1990\n5                Eros Eros Ramazzotti      EU            BMG  9.90 1997"
  },
  {
    "objectID": "DataAdquisition-01.html#leyendo-tablas-de-un-html",
    "href": "DataAdquisition-01.html#leyendo-tablas-de-un-html",
    "title": "Adquisición de datos",
    "section": "Leyendo tablas de un html",
    "text": "Leyendo tablas de un html\nProcedemos de manera similar a los xml. Creamos una variable con la ubicación del archivo:\n\nurl_html <- \"Datasets/Adquisition/WorldPopulation-wiki.htm\"\n\nExtraemos las tablas con:\n\ntablas <- readHTMLTable(url_html)\n\nEsto nos devuelve una lista con las tablas incrustadas en el archivo html. Si deseamos acceder a una lista en particular, por ejemplo, la 6; lo hacemos con el siguiente comando en una nueva variable llamada tabla6.\n\ntabla6 <- tablas[[6]]\nhead(tabla6, 5)\n\n  Rank Country / Territory    Population              Date\n1    1       China[note 4] 1,385,310,000 September 9, 2017\n2    2               India 1,321,010,000 September 9, 2017\n3    3       United States   325,732,000 September 9, 2017\n4    4           Indonesia   261,600,000  October 31, 2016\n5    5            Pakistan   208,848,000 September 9, 2017\n  Approx. % of world\\npopulation Source\n1                          18.3%   [91]\n2                          17.5%   [92]\n3                          4.31%   [93]\n4                          3.46%   [94]\n5                          2.76%   [95]\n\n\nLo anterior se puede realizar un poco mejor si ya conocemos de antemano la tabla a cargar. Veamos:\n\nnueva_tabla6 <- readHTMLTable(url_html, which = 6)\nnueva_tabla6\n\n   Rank Country / Territory    Population              Date\n1     1       China[note 4] 1,385,310,000 September 9, 2017\n2     2               India 1,321,010,000 September 9, 2017\n3     3       United States   325,732,000 September 9, 2017\n4     4           Indonesia   261,600,000  October 31, 2016\n5     5            Pakistan   208,848,000 September 9, 2017\n6     6              Brazil   207,985,000 September 9, 2017\n7     7             Nigeria   188,500,000  October 31, 2016\n8     8          Bangladesh   163,106,000 September 9, 2017\n9     9              Russia   146,773,226      June 1, 2017\n10   10               Japan   126,750,000      July 1, 2017\n   Approx. % of world\\npopulation Source\n1                           18.3%   [91]\n2                           17.5%   [92]\n3                           4.31%   [93]\n4                           3.46%   [94]\n5                           2.76%   [95]\n6                           2.75%   [96]\n7                           2.49%   [97]\n8                           2.16%   [98]\n9                           1.94%   [99]\n10                          1.68%  [100]"
  },
  {
    "objectID": "DataAdquisition-01.html#leyendo-datos-desde-un-json",
    "href": "DataAdquisition-01.html#leyendo-datos-desde-un-json",
    "title": "Adquisición de datos",
    "section": "Leyendo datos desde un JSON",
    "text": "Leyendo datos desde un JSON\nPara esta tarea debemos instalar un paquete adicional:\ninstall.packages(\"jsonlite\")\nCargamos el paquete:\n\nlibrary(jsonlite)\n\nY ahora cargamos los conjuntos de datos disponibles a su respectiva variable llamada json_data1 y json_data2:\n\njson_data1 <- fromJSON(\"Datasets/Adquisition/students.json\")\njson_data2 <- fromJSON(\"Datasets/Adquisition/student-courses.json\")\n\nMostremos la primera variable\n\nhead(json_data1, 5)\n\n    id          Name                Email      Major year\n1 1044   Fran Morton     fran.m@quama.edu Statistics 2015\n2 1035  Kato Mullins      tempor@giat.com  Marketing 2014\n3 1046 Jordan Keller        Cum@gmail.com  Chemistry 2014\n4 1084 Macey Simpson eu@famesacturpis.com    Finance 2016\n5 1010 Deanna Ortega  Dea.Ortega@velit.ca  Chemistry 2016\n\n\nEs posible acceder a los diferentes campos mediante la sintaxis del Peso ($):\n\njson_data1$Name\n\n [1] \"Fran Morton\"     \"Kato Mullins\"    \"Jordan Keller\"   \"Macey Simpson\"  \n [5] \"Deanna Ortega\"   \"Joe Eaton\"       \"Yoko Washington\" \"Ebony Farrell\"  \n [9] \"Quinn Delacruz\"  \"Magee Humphrey\"  \"Kaitlin Cooper\"  \"Carson Roy\"     \n\n\nTambién utilizando la selección por fila, por columna o ambas. Probemos con las primeras cinco filas y las primeras dos columnas:\n\njson_data1[1:5, 1:2]\n\n    id          Name\n1 1044   Fran Morton\n2 1035  Kato Mullins\n3 1046 Jordan Keller\n4 1084 Macey Simpson\n5 1010 Deanna Ortega\n\n\nAhora seleccionemos solamente las filas 2, 5 y 8:\n\njson_data1[c(2,5,8),]\n\n    id          Name                Email     Major year\n2 1035  Kato Mullins      tempor@giat.com Marketing 2014\n5 1010 Deanna Ortega  Dea.Ortega@velit.ca Chemistry 2016\n8 1074 Ebony Farrell efarrella@gravid.com Chemistry 2017\n\n\nY terminemos trayendo solo las columnas 2 y 5:\n\njson_data1[, c(2,5)]\n\n              Name year\n1      Fran Morton 2015\n2     Kato Mullins 2014\n3    Jordan Keller 2014\n4    Macey Simpson 2016\n5    Deanna Ortega 2016\n6        Joe Eaton 2014\n7  Yoko Washington 2017\n8    Ebony Farrell 2017\n9   Quinn Delacruz 2017\n10  Magee Humphrey 2016\n11  Kaitlin Cooper 2014\n12      Carson Roy 2017"
  }
]