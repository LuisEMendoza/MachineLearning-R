[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inicio",
    "section": "",
    "text": "En estos apuntes estaré escribiendo todo lo que vaya encontrando en la red sobre el Aprendizaje Máquina con el lenguaje R. Planifico crear otro sitio con apuntes sobre Python, Julia y probablemente Java.\nEl código R se muestra abajo y enseguida la salida.\n\n1 + 1\n\n[1] 2\n\n\nConforme se vuelvan más complejos estos apuntes iré agregando métodos más eficientes de navegación.\nSe debe instalar el paquete class con\ninstall.packages(\"class\")"
  },
  {
    "objectID": "SL-Classification-01.html",
    "href": "SL-Classification-01.html",
    "title": "Aprendizaje Supervisado en R: Clasificación",
    "section": "",
    "text": "Se trata de algortimos que utilizan la cercanía en cuanto a ciertos valores de las variables consideradas importantes para realizar una clasificación.\n\n\nDespués de haber tenido un humano detrás del volante por varios viajes, es hora de que el coche autónomo intente probarse a sí mismo.\nAl comienzo del viaje, la cámara obtiene la imagen de una señal vial de alto. Esta se;al ha sido codificada siguiendo parámetros que pueden ser leidos por el algoritmo y se almacenan en un conjunto de datos llamado next_sign. Apliquemos un clasificador kNN para ayudar al coche a reconocer la señal.\nCarguemos tanto la librería class como el set de datos signs, el cual contiene las observaciones de entrenamiento. Lo primero lo realizamos de la manera habitual:\n\nlibrary(class)\n\nLo segundo lo haremos de una manera diferente, ya que nuestros datos se encuentran en un archivo de texto independiente de RStudio. Utilizaremos read.csv() para leer el contenido del archivo que contiene nuestro set de datos.\n\nsigns <- read.csv(\"Datasets/signs.csv\")\n\nGuardaremos la lectura a una variable signs, que nos representará en los sucesivo al conjunto de datos. Ahora crearemos un vector de etiquetas, al cual le asignaremos el contenido de la columna sign_type contenida en el conjunto de datos signs. Recordemos que la selección de una columna se consigue con el símbolo $, indicando el set original y en seguida la columna de interés:\n\nsign_types <- signs$sign_type\n\nAhora cargaremos los datos que representan la imagen tomada que queremos clasificar:\n\nnext_sign <- read.csv(\"Datasets/next_sign.csv\")\n\nEs momento de realizar la clasificación de la nueva imagen con la función knn(). Configuraremos sus argumentos de la siguiente manera.\n\ntrain se refiere a los datos de entrenamiento o de ejemplo, y en este caso será igual al data frame signs pero retirando la columna de las etiquetas (recordemos que esa la usamos para el vector de etiquetas sign_types).\nEl argumento test se refiere a los datos que se desean clasificar. Utilizaremos los correspondientes al data frame next_sign.\nEl último argumento a utilizar será cl, al cual le alimentaremos el vector de etiquetas sign_types.\n\n\nknn(train = signs[, -1], test = next_sign, cl = sign_types)\n\n[1] stop\nLevels: pedestrian speed stop\n\n\nEl resultado arrojado nos indica que efectivamente, es una señal de Alto. Luego nos muestra los posibles resultados a esta cuestión.\n\n\n\nHemos conseguido enseñarle a la máquina a reconocer una señal de alto. Sin embargo, debemos conocer qué información le dimos para lograrlo. Básicamente, el conjunto de datos que alimentamos como el entrenamiento contiene una simplificación numérica de las imágenes que representan señales viales. Veamos cómo se obtuvieron.\nCada fotografía de señales viales fue dividida en una rejilla de 4x4, dando 16 partes representadas por cuadrados. Enseguida se extrajo el color del píxel central de cada uno de estos cuadros. El color fue cuantificado considerando el nivel RGB, es decir, la cantidad de rojo, verde y azul de dicho píxel. Recordemos que los valores RGB van desde 0 hasta 255. Así se obtuvo el conjunto de entrenamiento, con hasta 48 valores representando cada fotografía de señales viales.\nExploremos el set de datos. Primero el panorama general algo resumido con str():\n\nstr(signs)\n\n'data.frame':   205 obs. of  49 variables:\n $ sign_type: chr  \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" ...\n $ r1       : int  155 142 57 22 169 75 136 118 149 13 ...\n $ g1       : int  228 217 54 35 179 67 149 105 225 34 ...\n $ b1       : int  251 242 50 41 170 60 157 69 241 28 ...\n $ r2       : int  135 166 187 171 231 131 200 244 34 5 ...\n $ g2       : int  188 204 201 178 254 89 203 245 45 21 ...\n $ b2       : int  101 44 68 26 27 53 107 67 1 11 ...\n $ r3       : int  156 142 51 19 97 214 150 132 155 123 ...\n $ g3       : int  227 217 51 27 107 144 167 123 226 154 ...\n $ b3       : int  245 242 45 29 99 75 134 12 238 140 ...\n $ r4       : int  145 147 59 19 123 156 171 138 147 21 ...\n $ g4       : int  211 219 62 27 147 169 218 123 222 46 ...\n $ b4       : int  228 242 65 29 152 190 252 85 242 41 ...\n $ r5       : int  166 164 156 42 221 67 171 254 170 36 ...\n $ g5       : int  233 228 171 37 236 50 158 254 191 60 ...\n $ b5       : int  245 229 50 3 117 36 108 92 113 26 ...\n $ r6       : int  212 84 254 217 205 37 157 241 26 75 ...\n $ g6       : int  254 116 255 228 225 36 186 240 37 108 ...\n $ b6       : int  52 17 36 19 80 42 11 108 12 44 ...\n $ r7       : int  212 217 211 221 235 44 26 254 34 13 ...\n $ g7       : int  254 254 226 235 254 42 35 254 45 27 ...\n $ b7       : int  11 26 70 20 60 44 10 99 19 25 ...\n $ r8       : int  188 155 78 181 90 192 180 108 221 133 ...\n $ g8       : int  229 203 73 183 110 131 211 106 249 163 ...\n $ b8       : int  117 128 64 73 9 73 236 27 184 126 ...\n $ r9       : int  170 213 220 237 216 123 129 135 226 83 ...\n $ g9       : int  216 253 234 234 236 74 109 123 246 125 ...\n $ b9       : int  120 51 59 44 66 22 73 40 59 19 ...\n $ r10      : int  211 217 254 251 229 36 161 254 30 13 ...\n $ g10      : int  254 255 255 254 255 34 190 254 40 27 ...\n $ b10      : int  3 21 51 2 12 37 10 115 34 25 ...\n $ r11      : int  212 217 253 235 235 44 161 254 34 9 ...\n $ g11      : int  254 255 255 243 254 42 190 254 44 23 ...\n $ b11      : int  19 21 44 12 60 44 6 99 35 18 ...\n $ r12      : int  172 158 66 19 163 197 187 138 241 85 ...\n $ g12      : int  235 225 68 27 168 114 215 123 255 128 ...\n $ b12      : int  244 237 68 29 152 21 236 85 54 21 ...\n $ r13      : int  172 164 69 20 124 171 141 118 205 83 ...\n $ g13      : int  235 227 65 29 117 102 142 105 229 125 ...\n $ b13      : int  244 237 59 34 91 26 140 75 46 19 ...\n $ r14      : int  172 182 76 64 188 197 189 131 226 85 ...\n $ g14      : int  228 228 84 61 205 114 171 124 246 128 ...\n $ b14      : int  235 143 22 4 78 21 140 5 59 21 ...\n $ r15      : int  177 171 82 211 125 123 214 106 235 85 ...\n $ g15      : int  235 228 93 222 147 74 221 94 252 128 ...\n $ b15      : int  244 196 17 78 20 22 201 53 67 21 ...\n $ r16      : int  22 164 58 19 160 180 188 101 237 83 ...\n $ g16      : int  52 227 60 27 183 107 211 91 254 125 ...\n $ b16      : int  53 237 60 29 187 26 227 59 53 19 ...\n\n\nSupongamos que deseamos saber cuántas señales de cada tipo están contenidas en nuestros datos. Eso se consigue con la función table() con la columna de los tipos de señal como argumento (no olvidemos que es la primera columna).\n\ntable(signs[, 1])\n\n\npedestrian      speed       stop \n        65         70         70 \n\n\nEs posible revisar los niveles promedio de color de alguna columna específica con el comando aggregate(). Calculemos el promedio de color del décimo cuadro pero clasificado por tipo de señal:\n\naggregate(r10 ~ sign_type, data = signs, mean)\n\n   sign_type       r10\n1 pedestrian 108.78462\n2      speed  83.08571\n3       stop 141.08571\n\n\nDesglosemos esta función. El primer argumento es la forma de organizar los datos, la columna r10 con respecto a la que que contiene los nombres del tipo de señal; enseguida escribimos el nombre del conjunto de datos y al final cuál medida estadística deseamos calcular.\n\n\n\nAhora realizaremos una prueba de manejo que incluye 59 señales adicionales divididas en tres categorías: alto, límite de velocidad y paso peatonal. Al final de la prueba, debemos medir el nivel de éxito del coche en reconocer dichas señales. Seguiremos trabajando con nuestro conjunto de datos con la adición de los datos de prueba, llamados test_signs.\n\ntest_signs <- read.csv(\"Datasets/test_signs.csv\")\n\nClasifiquemos los datos de las señales de prueba con knn() y asignemos el resultado a una variable.\n\ntrain volverá a ser nuestros datos de entrenamiento sin etiquetas.\ntest se refiere ahora a los datos de prueba test_signs, también sin etiquetas.\ncl vuelve a ser el vector de etiquetas creado anteriormente.\n\n\nsign_types <- signs$sign_type\nsigns_pred <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types)\nsigns_pred\n\n [1] pedestrian pedestrian pedestrian pedestrian pedestrian pedestrian\n [7] pedestrian pedestrian pedestrian pedestrian pedestrian pedestrian\n[13] pedestrian pedestrian pedestrian pedestrian pedestrian pedestrian\n[19] pedestrian speed      speed      speed      speed      speed     \n[25] speed      speed      speed      speed      speed      speed     \n[31] speed      speed      speed      speed      speed      speed     \n[37] speed      speed      speed      speed      stop       stop      \n[43] stop       stop       stop       stop       stop       stop      \n[49] stop       stop       stop       stop       stop       stop      \n[55] stop       stop       stop       stop       stop      \nLevels: pedestrian speed stop\n\n\nR nos devuelve el conjunto de sus lecturas en cuanto a las señales viales que encontró en la prueba. Toca verificar qué tan preciso resultó ser nuestro modelo con respecto a las señales reales. Para ello, primero crearemos un vector con las etiquetas de las señales reales y después con la función table() crearemos una tabla cruzada o matriz de confusión que compare los valores pronosticados contra los reales:\n\nsigns_actual <- test_signs$sign_type\nsigns_actual\n\n [1] \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\"\n [6] \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\"\n[11] \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\"\n[16] \"pedestrian\" \"pedestrian\" \"pedestrian\" \"pedestrian\" \"speed\"     \n[21] \"speed\"      \"speed\"      \"speed\"      \"speed\"      \"speed\"     \n[26] \"speed\"      \"speed\"      \"speed\"      \"speed\"      \"speed\"     \n[31] \"speed\"      \"speed\"      \"speed\"      \"speed\"      \"speed\"     \n[36] \"speed\"      \"speed\"      \"speed\"      \"speed\"      \"speed\"     \n[41] \"stop\"       \"stop\"       \"stop\"       \"stop\"       \"stop\"      \n[46] \"stop\"       \"stop\"       \"stop\"       \"stop\"       \"stop\"      \n[51] \"stop\"       \"stop\"       \"stop\"       \"stop\"       \"stop\"      \n[56] \"stop\"       \"stop\"       \"stop\"       \"stop\"      \n\ntable(signs_pred, signs_actual)\n\n            signs_actual\nsigns_pred   pedestrian speed stop\n  pedestrian         19     0    0\n  speed               0    21    0\n  stop                0     0   19\n\n\nCalculemos la precisión de nuestro modelo:\n\nmean(signs_pred == signs_actual)\n\n[1] 1\n\n\nResultó ser totalmente preciso, lo cual no es normal que ocurra siempre.\n\n\n\nEl valor de la constante k permite modificar el rendimiento de nuestros algoritmos. La k se refiere al número de vecinos a tomar en cuenta para la clasificación. Por ejemplo, si lo dejamos sin modificar, R dará un valor de k = 1, por lo que elegirá solo la imagen más cercana a la prueba. Si incrementamos el valor, se tomará en cuenta tantos vecinos como valga la k y eso podría redundar en una mayor exactitud del modelo al tener más elementos que considerar. Sin embargo, esto no siempre es lo mejor, ya que valores pequeños pueden detectar patrones más sutiles en nuestro modelo.\nProbemos valores de k a 1, 7 y 25 para examinar su impacto en la exactitud del modelo de aprendizaje:\n\nk_1 <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types)\nmean(signs_actual == k_1)\n\n[1] 1\n\n\nAhora probemos con 7 vecinos.\n\nk_7 <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types, k = 7)\nmean(signs_actual == k_7)\n\n[1] 0.9661017\n\n\nY con 25:\n\nk_25 <- knn(train = signs[, -1], test = test_signs[, -1], cl = sign_types, k = 25)\nmean(signs_actual == k_25)\n\n[1] 0.9322034"
  }
]